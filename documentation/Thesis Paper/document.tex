% Document formatting and includes
\documentclass[12pt]{article}
\usepackage[a4paper,left=3cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage[hyphens]{url}
\usepackage{hyperref}
\providecommand{\keywords}[1]{\textbf{\textit{Index terms---}} #1}
\usepackage[none]{hyphenat}



%opening
\title{Application development with microservices\\ in Enterprise Java\\ A Spring Boot Case Study}
\author{Lennart Cockx\\Guangming Luo}

\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

\begin{abstract}
\noindent In this report we will explore various Java technologies and analyse what features they offer. The focus of this project is to find which frameworks are most suitable for quick prototyping of a business application. Constraints and other requirements will be defined and are then applied to a specific case study. At the end of this project we should have an excellent understanding of the technologies involved to make a online cash register application that handles orders and payment in restaurants. [WIP]
\end{abstract}
\keywords{JavaEE, Spring, Cash register, Java}

\section{Project Objective}
\subsection{Proposal}
This master thesis is commissioned by Faros, a Cronos group company specialized in the development of Java web applications and primarily focused on designing Rich Internet Applications. Development within Faros is done mainly with Vaadin, Spring, HTML5, ExtJS, JavaScript, JSP, JSF, NoSQL and more. This means that during this thesis, special attention is given to these technologies in regards to design choices. Naturally, comparisons with other possible frameworks will still be done and valid arguments will be set forward to confirm these decisions.
\\\\
The following case study was proposed by Faros: designing an online cash register that can be used in restaurants or at events. Existing cash register systems are expensive and for smaller establishments or temporary events, this investment is not worth it. The idea is to use existing devices from employees and customers to handle the ordering and payment process.
\\\\
This project is an opportunity for us to learn about the frameworks and technologies used for the development of rich, interactive web applications. Additionally, we want to explore the best methods to quickly build a web application from scratch. Some key aspects that we will look out for are: Documentation availability, speed of new project setup, customizability, integration with other frameworks and security features. When given the corresponding documentation, it should be possible to reproduce this application. During the design and development of this project we want to describe the problems we faced and how we solved them. This will give other students the option to learn from our mistakes and hopefully help them increase their understanding of Java EE concepts. 
\subsection{Concept}
At the start of the project we discuss the key aspects of this project with our coaches at Faros. Based on the requirements provided by them, combined with our own interests, we will define the general field we will be working in. 
\\\\
After we have a good overview of what aspects must be included in this project (or should be avoided), we can start deciding core features that will determine which technologies will be appropriate for this project. These choices are based on the aspects we think are needed for developing a web application based on the aforementioned requirements. This should give us a list of possible systems and frameworks that could potentially be used during this project.
\\\\
Now that we have a list of possible systems, we can start to think about the case study we want to develop. Given the general outline of the project, we can begin selecting the appropriate tools and frameworks that fit this case study. This will shorten the list to technologies specifically applicable to this project. For certain frameworks it will be difficult to obtain a shorter list, as they might all comply with the requirements we set. In this case we will make a selection of items to keep the scope of the project realistic. Usually the most popular frameworks will be selected. If a deviating set is chosen this will be elaborated on in the corresponding chapter.
\\\\
Now that the tools are known, the standard procedure for application development will be followed. Relevant documentation will be constructed including a use case analysis, feature description (Nice-to-have versus Must-have), navigational models, hierarchical task analysis, UML diagrams and market research. After this we can start working on getting familiar with the chosen enterprise Java frameworks.
\\\\
As soon as we are sufficiently proficient with our chosen tools, we will start working on a case study where we use the knowledge we obtained to build a functional prototype for a realistic use case scenario. During the project we might come to the conclusion that certain choices we made were suboptimal or simply do not allow further progression. In such cases, we will adjust our trajectory and change to the appropriate tools. Any time such a decision is made we will mention it in this report and provide the matching argumentation as to why we made the switch.
\subsection{Project Requirements}
\subsubsection{Constraints}
As this project is appointed by Faros, there are certain guidelines we will follow during this study. The primary constraint is the usage of Java. As Faros is a Java consultancy company, the technology stack we use should match what the employees there utilize. Within Java we are still free to choose what frameworks will be used. Another constraint is that we should not aim to create a perfectly working application with extensive styling and fail-safes, but rather focus more on experimenting with various different systems to get a better overview of the big picture and compare these systems with each other. There are also certain project-specific constraints that will be detailed in the case study.
\subsubsection{Design focus}


\subsection{Existing systems}
Before creating our own Online cash register application we searched for similar systems that already exist. One of such systems is Gloriafood \cite{Gloriafood:online}. This is an online system that allows any restaurant owner to sign up and start receiving orders online. A extensive layout is available where you can add a menu and payment options.
\\\\
Similarly, there is ChowNow \cite{Chownow:online}. This service also handles online ordering and payment with no extra input required from the restaurant manager. ChowNow will also create a custom branded mobile application to showcase the brand and food of the restaurant.
\\\\
Both of these systems are focused on the online ordering aspect and not so much on allowing people to use their devices to order food on location. In this project we want to put the emphasis on the latter part, creating an application that is meant to be used at the location itself.



\section{Research and Methods}
\subsection{Approach}
We will take a quantitative approach in this paper, exploring and comparing frameworks for each of the features required for this project. This includes: General frameworks providing a way to couple web resources to Java code. Persistence providers, SQL or noSQL databases to store customer information. Object relational mapping tools to generate mappings from existing data-stores. Security systems to allow authentication and authorization in a safe way. Front-end frameworks, providing styling options and client side scripting.
\subsection{Java EE Landscape}
We will not discuss every existing tool in the Java environment, but it might be interesting to have a look at the current state of Java EE in the professional world. We will use the numbers from a survey published by Zeroturnaround to do our analysis.\cite{JavaEELandscape73:online} This website has a blog for Java web developers and will display a certain bias towards this usergroup. For more general statistics please refer to Stackoverflow's developer survey.\cite{DeveloperSurvey95:online}
\\\\
Currently the majority of Java developers work on full-stack web applications (67\%), a smaller group works on back-end code only (18\%) with the rest of the developers divided into batch scripting, mobile apps, desktop applications, etc... This shows us that only in a fragment of the projects specialization is beneficial. Usually developers know and work with both front-end and back-end technologies. This is also what we will do during this project, implementing both the front-end and back-end of the application.
\\\\
So which front-end and back-end frameworks are used by developers? The most commonly used web framework is Spring MVC (43\%), followed closely by Spring Boot (29\%). Practically, this means that over 70 percent of respondents use the Spring framework. Spring Boot itself is not really a framework, but rather a streamlined entry point to the Spring ecosystem with a "Opinionated Defaults Configuration" approach. \cite{SpringBootAdvantages67:online}\cite{SpringBootIntro23:online} Other common web frameworks are JavaServer Faces (19\%), Vaadin (13\%) and Struts (7\%). Other frameworks exist but are too numerous to list. For this project we will limit ourselves to analysing the 3 most popular frameworks. This should give us a good idea of the advantages that web frameworks offer, and how they compare. Spring Boot in particular looks promising as it provides autoconfiguration for many properties which will be advantageous for people new to the Java EE platform. It is also worth mentioning that 17 percent replied that they do not use any framework. It seems that for certain projects using a framework is not worthwhile. % This could also be a point of discussion for our thesis
\\\\
When working with frameworks, developers will make use of build tools to avoid having to manually invoke the steps in the compilation process. The most popular build tools for Java are Apache Maven (68\%), Gradle (16\%) and Apache Ant(11\%). While using a different build tool won't directly affect the result of a project, it is important to make an appropriate choice from the start. This build tool will be shared by all teammates in a project. 
\\\\
To deploy the application, an application server is needed. For production, Tomcat (42\%) is the primary choices for running Java web applications. The rest of the users are quite evenly distributed over the other application servers with the most popular being Jetty (12\%), Wildfly (10\%) and JBoss EAP (7\%). Developers have the choice of running their own application server and deploying their apps to it or making an application with an embedded server. For us, using an embedded server will get our project up and running faster. We will also run an external server to learn how this changes the development cycle. 
\\\\
While not directly related to specific technologies, the survey also asked participants to indicate whether they have adopted a microservices architecture. This is interesting for us to look into as it was mentioned by our coaches at the company. It seems that microservices have become quite popular in recent year for a variety of reasons.\cite{WhyMicroservices48:online} Although it differs from the usual approach we learned during our education, trying to use this architecture in our application might provide valuable insights if we succeed.  
\\\\
Something that is not mentioned in the survey is security. Basic security is expected in any web application, but implementing a secure system is difficult. Java EE already provides the building block for securing a web application, but part of the design is still up to the developers themselves.\cite{JavaEESecurity29:online} Modern Java web frameworks go a step further however, giving developers a production ready security system out of the box. E.g. with Spring boot using Spring Security offers a system with built-in authentication and authorization. Safety and resilience are key factors that have to be taken into account when developing our application.
\\\\
Another aspect not discussed in the survey is front-end frameworks. Commonly, the interface of a web application is designed using HTML, CSS and Javascript. On top of this CSS and javascript libraries like Bootstrap and JQuery can be used to speed up development by giving access to pre-made modules for frequently used interface elements. Front-end frameworks such as AngularJS and libraries like React can be used to speed up development even further. They offer tools and design guidelines to make designing interactive interfaces efficient and fast. Although we will also discuss these frameworks in this paper, priority will be given to technologies related to the back-end while styling will take a back seat.
\\\\
Finally, what types of databases are used to store information? The most used database are OracleDB (39\%), MySQL (38\%) and PostgreSQL (29\%). All three are relational databases. The most used NoSQL databases are MongoDB (15\%) and Redis (8\%). Note that these results are multiple choice, as some projects use multiple databases simultaneously. For the case study, the selection of database will depend on the type of data we want to store. Most of our experience is with relational databases, so trying out a NoSQL database will be valuable experience.
\\\\
Hopefully this section gave some insight into the technologies used in Enterprise Java Development and how we will approach them in our project. We want to try out various technologies and determine those most suitable for the use case and our development style. In the next section a more detailed explanation of the technologies will be given. During the exploration of these frameworks we will already create a prototype for the case study. This will give us a better idea of which features would be beneficial for this specific project.

\subsection{Case study summary}
% TODO add section that specifies basic requirements of the case study and explain why these might or might not match what we write down here.
\subsection{Comparison of technologies}
Even before we specify the case study for our project we can already try out the different technologies discussed in the previous subsection and make a selection of those we deem appropriate for this master thesis. These choices should not be affected by our specific case study, but it will be kept in mind.
\subsubsection{IDE's and build tools}
While the development environment and build tools are essential in application development. The choice itself is based on the preferences of the individual programmer. This project started out with the Netbeans environment and Maven for dependency management. When we started using Spring we tried out the Spring Tool Suite based on Eclipse, but we finally settled on IntelliJ IDEA and Gradle. IDEA offers many tools often needed during development such as a database editor, gradle/maven task execution, ORM modules, bitbucket plugin support, REST client for testing, superior auto-completion and built-in support for many frameworks. There are several other advantages to using IDEA, but these were the most determining factors causing us to switch environment. For the build tool, Maven is actually not inferior to Gradle. Both support the dependency injection that we need for this project. The primary reason we decided to try it out was curiosity. Gradle is currently the default build tool in Android development with android studio, and it is also utilized in Grails and Netflix OSS. When comparing them directly, Gradle seems to offer a much richer feature set. \cite{GradleVsMaven48:online} When using this build tool in the project, we came to the conclusion that these extra features were not really a necessity for our specific application. We did stick to Gradle in the end though, as the DSL syntax that it uses makes for a much more readable build file in comparison to the XML notation that Maven uses. We did stumble upon some issues while using Gradle. It also uses the Maven repositories for its dependencies, which means that if you want to add your own dependency to the local Maven repository, you will need to enable the maven-publish plugin within Gradle and add the relevant build code to bundle it correctly. Compare this to Maven, where executing the install task achieves the same result. In general, the choices we made for this section are based on our own preferences and experiences during the project.
\subsubsection{General framework}
The general framework will be the decisive element in the case study we develop. It will determine what modules we can use during development and what the general architecture looks like. Once we choose a certain framework, it will be difficult to convert to another. Our first iteration of this project started off as a plain Java EE project which served pages with the JSF framework. Apart from the configuration issues we had when first starting out, this worked quite well for simple servlets and beans. We created the necessary entity beans and business logic in an EJB package. Servlets, JSP files and static web content were packaged into a web archive. Both these packages were then combined into an Enterprise Application archive and deployed to a glassfish server. There were two big problems with this. First, configuring the application and server during the first setup takes a significant amount of time. The data sources must be configured in both the .ear as well as in the application server itself. When changing database or server this configuration must be redone. During development this can be a burden since we have to reconfigure should we want to make significant changes. Also, when we implement a microservices architecture, it will be necessary to repeat this configuration for every service. The other major problem is technology selection. Most technologies we use will be based on the specific requirements of the case study. For many other parts of the project there are still technologies that are used for any type of project, like what application server do we use?, what object mapping tool? and what security framework? plus many other systems that we didn't know the existed yet. Figuring out what systems we need and how to configure them will take a significant amount of time and they won't necessarily be the optimal choices. To avoid spending too much time here, we can use a framework which already implements these features for us in a production ready package. This way we can already start exploring and working with certain features without having to implement it all ourselves. Most frameworks still allow changing the preconfigured defaults to different system where necessary. Searching for these prerequisites led us to the Spring framework. Or rather, the Spring Boot ecosystem. 
\\\\
Like mentioned before, Spring Boot provides an opinionated toolset which gets you up and running in no time. All the necessary components are automatically configured and ready for deployment. For us this is ideal, we can quickly get started and we can learn about the necessary modules for deploying a Java Enterprise application by examining the code generated by the Spring Boot Initializer. Another interesting aspect about Spring is that it is considered an excellent base for designing applications following a microservices architecture. \cite{SpringMicroservices35:online} \cite{MicroservicesFrameworks85:online} Of course there are other frameworks that offer similar autoconfiguration and tools for implementing microservices, most notably Dropwizard and Vertx. The reason we decided to go for Spring Boot first is that, due to its popularity, it has great documentation and is very comprehensive, containing an extensive set of modules for all things required for modern web applications. Additionally, it is compatible with a wide range of other frameworks, so if we would need specific features from another framework this is still possible. This choice proved to be very good, we managed to reimplement the existing project we had in a matter of days and continued working in this framework. More details about our further steps in section \ref{sec:implementation}.
\subsubsection{Persistence providers}
Data storage is practically utilized in any web application. We will need at least a way to store information for authentication purposes. In addition, we will likely need to store data related to the restaurant and menus. When storing relational data, a SQL database is typically used. Because we are taking a microservices approach and want to explore scalability, a NoSQL database might be more suitable. 
\subsubsection{Object relational mapping tools}
\subsubsection{Security systems}
\subsubsection{Front-end and Styling frameworks}
\subsection{Implementation}\label{sec:implementation}





\section{Case study: Online cash register}
\subsection{Introduction}
The goal of this case study is to create a service that can be used at events and in restaurants to process orders made by customers, relay these orders to the waiters and chefs and handle the payment. This service should include an application that clients can use to view the menu and order items from it. Waiters also have their own application that can place and acknowledge orders. These orders will be send to a central system that manages all the required information. See fig. \ref{fig:usecase} for a use case diagram.
\subsection{Use Cases}
In this case study we can identify several distinct actors that will interact differently with the application.
\paragraph{Customer}
The customer is the primary user of this application. They access the menu of a specified restaurant or event. They can place orders, either via the application itself or from a waiter with their own device. Finally, they can pay for the orders that they placed. Again, either via the application or a waiter.
\paragraph{Waiter}
Like the customers, the waiter can access the menu of their restaurant and place orders for their clients. In addition to this they can display an overview of the currently queued orders, with the corresponding table numbers or location. They will also handle payments from customers through the application, or accept payment in other forms of currency.
\paragraph{Chef}
The chef can access similar functions as the waiter. Additionally, they can modify the status of an order and mark it as completed or in progress.
\paragraph{Manager}
The manager can modify the menu and change prices. They can also create accounts for employees and give them the corresponding privileges.\\

%should also have some information about multi-tenancy
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.75\linewidth]{usecase.jpg}
	\caption{Use Case Diagram}
	\label{fig:usecase}
\end{figure}

\subsection{Must-haves and nice-to haves}
As soon as we had the use cases defined, we can specify what features are absolutely essential and which are optional. This was done in collaboration with our coaches at Faros and gave us the following specifications.
\paragraph{Must-Haves}
\begin{itemize}
	\item The system can be used by multiple managers or event-organizers simultaneously. 
	(\textit{Multi-tenancy})
	\item A central application will handle orders and payment. 
	(\textit{Central application})
	\item Waiters can use an application to send the orders of customers to the kitchen and accept payment. 
	(\textit{Employee interface + Payment system})
	\item Customers can view the menu of the restaurant/event with their mobile device. 
	(\textit{Customer interface})
	\item An order overview is available for the waiters and chefs. It shows the completed orders and orders which have to be made. 
	(\textit{Order overview})
	\item Customers can add comments to certain orders. E.g. no tomato
	(\textit{Special requests}) 
	\item Customers can place their own orders with their mobile device. 
	(\textit{Customer Mobile ordering})
	\item Prevent customers from making ridiculous orders or misusing the system.
	(\textit{Misuse prevention})
\end{itemize}
\paragraph{Nice-to-Haves}
\begin{itemize}
	\item Event organizers can run the central application on their own local network. 
	(\textit{Local network hosting})
	\item After an order is finished, the completed order number is shown on a big screen. 
	(\textit{Take-a-number/Now serving System})
	\item The manager can find statistics on his restaurant and orders via a web app. 
	(\textit{Order Statistic}s)
	\item Customers can split the bill or combine orders 
	(\textit{Bill splitting})
	\item Provide an easy way for customers to use our system at an event/restaurant. Even if they don’t know it yet. 
	(\textit{Easy access})
	\item Customers can order additional food or drinks. This will be added to the total bill.
	(\textit{Multiple orders})
	
\end{itemize}

\subsection{Technology choices}
\subsubsection{Application type}
\subsubsection{Framework choices}
\subsection{Design Choices}
\subsubsection{Client}
%Possibly insert pictures we designed
%This part will need to be reviewed as changes to the design were made
We want to make an application for customers of restaurants and events. The customer can use this application to get an overview of the available menu items and prices. If the customers have decided, they can order the desired dishes straight from the application. Finally, the customers can pay for their meal with this application.
We can differentiate a couple of different scenarios when the customer goes to a restaurant or event that supports this system. We assume that a web app is used. If a native or hybrid application is used, installing the app will be an additional step before using the system.
\\\\
After (or before) the meal is finished, customers should be able to pay directly from within the application or pay a waiter. When using the application to place an order for multiple people, the customers should have the option to order and pay separately or order together and split the cost. 
For example: Three people want to place an order, two of which have access to the application. 
\begin{itemize}
\item One person can place the order for the entire group.
\item One person can order for himself and the person without the application. While the third person makes his own choice with his own device.
\item The two persons with the application order for themselves, while the other person orders something from a waiter.
\end{itemize}

\noindent 
In all three cases the order will be combined into one order for that table. After the meal the bill can be paid for.

\begin{itemize}
	\item One person decides to pay for the entire bill. This can be paid to a waiter or with his application.
	\item Each person pays for the part he ordered separately, with the price corresponding to what they ordered.
	\item Everyone decides to split up the bill equally, dividing the total cost over three people. 
\end{itemize}

\noindent
Typically, when people eat at a restaurant, they will place multiple orders. During the meal additional drinks might be ordered and at the end of the meal some people might want a dessert or coffee. We must design the application so it can accept multiple orders and display the sum of these orders at the end of the meal.


\subsubsection{Employee}
To be able to interact with customers using this system, the waiters and chefs will need their own version of this application. They will need to get an overview of the current orders placed and they should be able to modify and confirm these orders.
\\\\
The order overview will have all the relevant information of the order: The different dishes and drinks ordered by the customer, the table from which the order was placed, the price and the status of the order. Additional information such as a time and date and an order number can be added for statistical purposes.
The order overview could look something like displayed in fig. \ref{fig:orderview}.
\begin{figure}[h!]
	\includegraphics[width=\linewidth]{orderview.PNG}
	\caption{Example Order Overview}
	\label{fig:orderview}
\end{figure}
\\
Whenever an order is served, it will be removed from the overview and the next item will be moved up. When the bill is requested, all orders from the corresponding table will be added together. After payment the orders for that table are reset to allow the next customers to place their order.
\\\\
In some cases, an order might be wrong or a mistake with the number of dishes is made. The application should be flexible and allow a waiter to make small modifications to the order to correct a mistake.
Additionally, a customer might make a special request for his order. This can be due to allergies or plainly because of a certain preference. It might be useful to provide a bit of space to the order overview for extra remarks.
\\\\
An order might contain a lot of different items. The full names of these items will take a lot of space in the order overview. Typically, a shorthand notation is used by waiters to more efficiently note down and read orders. A similar system could be used for the order overview.
Also, for showing the menu to the customer we will display a vertical list with the name of every menu item. This list will contain detailed information like the name of the dish, the ingredients, pricing and possibly even a picture. These menu items can be sorted into categories for easy navigation. On the other side, the waiter does not need all the detailed information. Instead a compact and efficient layout is preferred to be able to easily take an order. This could be a grid layout with simple icons or abbreviations for each dish. See fig. \ref{fig:waitercustomer}.
\begin{figure}[h!]
	\begin{subfigure}{.5\textwidth}
		\includegraphics[width=0.9\linewidth]{customermenu.PNG}
		\caption{Customer Menu Layout}
		\label{fig:menucustomer}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\includegraphics[width=0.9\linewidth]{waitermenu.PNG}
		\caption{Waiter Menu Layout}
		\label{fig:waitercustomer}
	\end{subfigure}
	\caption{Menu Layouts}
	\label{fig:menus}
\end{figure}

\noindent \\It is possible that certain people with bad intent might try to place orders for ridiculous amounts of food, repeatedly place small orders to fill the system or even place orders for another table. Some of these situations can be prevented with proper programming like limiting the amount of orders one table can make each minute. Another way to prevent some of these issues is to have waiters confirm orders on their device before adding them to the kitchen. In day to day use, these scenarios will be rare, but it’s still important to think about the possible problems that might occur. 
While a user account for the customer might be desirable to track certain statistics and prevent misuse of the system (like mentioned above), requiring an account might not be interesting, as this can make the process of using the application slow and unintuitive for the customer.


\subsubsection{Manager}
The manager will be able to create new accounts for employees that work in their restaurant. They can modify properties of the restaurant and alter the menu and prices. 
\\\\
One of the most important aspects to consider here is multi-tenancy. The application should not only provide an interface for a certain restaurant but should be usable by different managers who own different restaurants. In other words the application should be generic and allow for customization for each restaurant separately.
\subsubsection{Remarks and challenges}
\subsection{Major issues and their solutions}

\section{Results}
\subsection{Final Prototype}
\subsection{User tests}

\section{Conclusion}


\newpage
\section{References}
\bibliographystyle{plain}
\bibliography{document}

\end{document}
